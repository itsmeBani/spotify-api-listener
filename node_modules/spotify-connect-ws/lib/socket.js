'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotify = require('./spotify');

var C = {
  CONNECT_ERROR: 'spotify_connect_error',
  HAS_SCRUBBED_THRESHOLD: 1500,
  HAS_FINISHED_THRESHOLD: 2000,
  POLL_RATE: 1000
};

var spotifyConnectWs = function spotifyConnectWs(socket) {
  socket.use(function (packet, next) {
    if (packet[0] !== 'initiate') {
      if (!socket.accessToken) {
        return socket.emit(C.CONNECT_ERROR, 'Access token not found: ensure to `initiate` with an access token before attempting other requests.');
      }
    }
    next();
  });

  var handleError = function handleError(error) {
    var message = error.message || error;
    if (message !== socket.lastSentError) {
      socket.emit(C.CONNECT_ERROR, error);
      socket.lastSentError = message;
    } else {
      socket.pollRate = socket.pollRate < 5000 ? socket.pollRate + 1000 : 5000;
    }
  };

  socket.on('disconnect', function () {
    socket.poll = function () {};
  });

  socket.on('initiate', function (_ref) {
    var _ref$accessToken = _ref.accessToken,
        accessToken = _ref$accessToken === undefined ? null : _ref$accessToken;

    if (!accessToken && !socket.accessToken) {
      return socket.emit(C.CONNECT_ERROR, 'An access token is required in order to start listening for playback events');
    }

    socket.accessToken = accessToken;
    socket.poll();
  });

  socket.poll = function () {
    (0, _spotify.getPlayerState)(socket.accessToken).then(function (playerState) {
      if (!playerState.device) {
        handleError('No active device');
        return;
      }
      if (!socket.hasSentInitialState) {
        socket.emit('initial_state', playerState);
        socket.playerState = playerState;
        socket.hasSentInitialState = true;
        return;
      }

      // reset poll rate if no errors were encountered
      socket.pollRate = C.POLL_RATE;

      if (playerState.item.id !== socket.playerState.item.id) {
        // track has changed
        socket.emit('track_change', playerState.item);
        socket.hasNotifiedTrackEnd = false;
      } else {}

      // check if the track has been scrubbed
      var negativeProgress = playerState.progress_ms > socket.playerState.progress_ms + C.HAS_SCRUBBED_THRESHOLD;
      var positiveProgess = playerState.progress_ms < socket.playerState.progress_ms - C.HAS_SCRUBBED_THRESHOLD;
      if (negativeProgress || positiveProgess) {
        socket.emit('seek', playerState.progress_ms, playerState.timestamp);
      }
      if (playerState.is_playing !== socket.playerState.is_playing) {
        // play state has changed
        var event = playerState.is_playing ? 'playback_started' : 'playback_paused';
        socket.emit(event);
      }
      if (playerState.device.id !== socket.playerState.device.id) {
        // device has changed
        socket.emit('device_change', playerState.device);
      } else {
        // device is the same, check volume
        if (playerState.device.volume_percent !== socket.playerState.device.volume_percent) {
          // volume has changed
          socket.emit('volume_change', playerState.device.volume_percent);
        }
      }

      if (!socket.hasNotifiedTrackEnd && playerState.progress_ms + C.HAS_FINISHED_THRESHOLD > playerState.item.duration_ms) {
        socket.emit('track_end', playerState.item);
        socket.hasNotifiedTrackEnd = true;
      }

      socket.playerState = playerState;
    }).catch(handleError);

    setTimeout(socket.poll, socket.pollRate);
  };

  socket.on('play', function (track) {
    if (track) {
      (0, _spotify.playTrack)(socket.accessToken, track).catch(handleError);
    } else {
      (0, _spotify.setPlayState)(socket.accessToken, 'play').catch(handleError);
    }
  });

  socket.on('resume', function () {
    (0, _spotify.setPlayState)(socket.accessToken, 'play').catch(handleError);
  });

  socket.on('pause', function () {
    (0, _spotify.setPlayState)(socket.accessToken, 'pause').catch(handleError);
  });

  socket.on('seek', function (positionMs) {
    (0, _spotify.seek)(socket.accessToken, positionMs).catch(handleError);
  });

  socket.on('set_volume', function (volumePercent) {
    (0, _spotify.setVolume)(socket.accessToken, volumePercent).catch(handleError);
  });

  socket.on('next_track', function () {
    (0, _spotify.nextTrack)(socket.accessToken).catch(function (e) {
      return socket.emit(C.CONNECT_ERROR, e);
    });
  });

  socket.on('previous_track', function () {
    (0, _spotify.previousTrack)(socket.accessToken).catch(handleError);
  });

  socket.on('transfer_playback', function (device) {
    (0, _spotify.transferPlayback)(socket.accessToken, device).catch(handleError);
  });

  socket.on('access_token', function (accessToken) {
    socket.accessToken = accessToken;
  });
};

exports.default = spotifyConnectWs;